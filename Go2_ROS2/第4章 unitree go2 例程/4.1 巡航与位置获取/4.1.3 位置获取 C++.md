colcon build --packages-select go2_tutorial
. install/setup.bash
ros2 launch go2_tutorial go2_state.launch.py

ros2 run go2_tutorial go2_state

1. 案例简介
订阅里程计消息，当机器人位移超过设定阈值时，输出一次当前坐标
订阅里程计消息，并计算与上个点的距离

2. 配置
1 在go2_tutorial 的 src 下创建 go2_state.cpp ,并导入模板
2 package.xml 添加: `<depend>nav_msgs</depend>`
3 cmakelist :
```
# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(unitree_go REQUIRED)
find_package(unitree_api REQUIRED)
find_package(nav_msgs REQUIRED)

add_executable(go2_ctrl src/go2_ctrl.cpp)
add_executable(go2_state src/go2_state.cpp)

target_include_directories(go2_ctrl PUBLIC
$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
$<INSTALL_INTERFACE:include>)
target_compile_features(go2_ctrl PUBLIC c_std_99 cxx_std_17) # Require C99 and C++17
ament_target_dependencies(
go2_ctrl
"rclcpp"
"unitree_go"
"unitree_api"
)
ament_target_dependencies(
go2_state
"rclcpp"
"unitree_go"
"unitree_api"
"nav_msgs"
)

install(TARGETS go2_ctrl
DESTINATION lib/${PROJECT_NAME})
  
install(TARGETS go2_state
DESTINATION lib/${PROJECT_NAME})

install(DIRECTORY launch params
DESTINATION share/${PROJECT_NAME})
```

3. launch 下创建 go2_state.launch.py
```
from launch import LaunchDescription

from launch_ros.actions import Node

# 封装终端指令相关类......

# from launch.actions import ExecuteProcess

# from launch.substitutions import FindExecutable

# 参数声明与获取......

# from launch.actions import DeclareLaunchArgument

# from launch.substitutions import LaunchConfiguration

# 文件包含相关......

from launch.actions import IncludeLaunchDescription

from launch.launch_description_sources import PythonLaunchDescriptionSource

# 分组相关......

# from launch_ros.actions import PushRosNamespace

# from launch.actions import GroupAction

# 事件相关......

# from launch.event_handlers import OnProcessStart, OnProcessExit

# from launch.actions import RegisterEventHandler

# from launch.actions import LogInfo

# 获取功能包下share目录路径......

from ament_index_python.packages import get_package_share_directory

import os

  

"""

启动驱动

加载位置获取节点

"""

  

def generate_launch_description():

# 包含驱动

go2_driver_pkg = get_package_share_directory("go2_driver")

go2_driver_launch = IncludeLaunchDescription(

launch_description_source=PythonLaunchDescriptionSource(

launch_file_path=os.path.join(go2_driver_pkg,"launch","driver.launch.py")

)

)

return LaunchDescription([

go2_driver_launch,

Node(

package="go2_tutorial",

executable="go2_state",

parameters=[os.path.join(get_package_share_directory("go2_tutorial"),"params","go2_state.yaml")]

)

])
```
4. 编写go2_state.cpp:
```
/*

需求：订阅里程计消息，当机器人位移超过阈值，输出当前坐标

实现流程：

1.订阅里程计消息

2.在订阅方的回调函数中，计算当前机器人位置与上一个记录点的距离，

如果大于阈值就输出坐标并更新

3.生成第一个记录点

当第一次订阅里程计消息时，就为记录点赋值

  

*/

  

#include "rclcpp/rclcpp.hpp"

#include "nav_msgs/msg/odometry.hpp"

  

using namespace std::placeholders;

class Go2State : public rclcpp::Node

{

public:

Go2State(): Node("go2_state")

{

// 构造函数：初始化发布者、订阅者、服务等

RCLCPP_INFO(this->get_logger(), "Hello from my ROS 2 node!");

last_x = last_y = 0.0;

is_first = true;

this->declare_parameter("distance",0.5);

odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>("odom",10,std::bind(&Go2State::odom_cb,this,_1));

}

  

private:

// 成员变量（如发布者、订阅者）声明

rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;

double last_x,last_y;

bool is_first;

void odom_cb(const nav_msgs::msg::Odometry::SharedPtr odom){

// 初始化第一个记录点

// 获取当前坐标

double x = odom->pose.pose.position.x;

double y = odom->pose.pose.position.y;

  

// 如果是第一次订阅到消息--赋值

if (is_first)

{

last_x = x;

last_y = y;

is_first = false;

RCLCPP_INFO(this->get_logger(),"起点坐标:(%.2f,%.2f)",last_x,last_y);

return;

}

  

// 计算是否超过阈值

double distance_x = x - last_x;

double distance_y = y - last_y;

  

// 计算距离

double distance = sqrt(pow(distance_x,2) + pow(distance_y,2));

  

if (distance > this->get_parameter("distance").as_double())

{

// 输出坐标

RCLCPP_INFO(this->get_logger(),"坐标:(%.2f,%.2f)",x,y);

last_x = x;

last_y = y;

}

}

};

  

int main(int argc, char ** argv)

{

// 初始化 ROS 2

rclcpp::init(argc, argv);

// 创建节点并开始自旋（处理回调）

auto node = std::make_shared<Go2State>();

rclcpp::spin(node);

// 关闭 ROS 2

rclcpp::shutdown();

return 0;

}
```
5. params 下创建 go2_state.yaml
获取参数：`ros2 param dump /go2_state`
```
/**:
ros__parameters:
distance: 0.3
use_sim_time: false
```