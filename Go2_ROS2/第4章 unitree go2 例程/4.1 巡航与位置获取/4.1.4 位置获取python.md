colcon build --packages-select go2_tutorial_py
. install/setup.bash
ros2 launch go2_tutorial_py go2_state.launch.py

ros2 run go2_tutorial_py go2_state


1. go2_tutorial_py 下 创建 go2_state.py
2. package.xml: <depend>nav_msgs</depend>
3. setuo.py: 
```
entry_points={
'console_scripts': [
'go2_ctrl = go2_tutorial_py.go2_ctrl:main',
'go2_state = go2_tutorial_py.go2_state:main'
],
},
```
4. launch 下创建 go2_state.launch.py :
```
from launch import LaunchDescription

from launch_ros.actions import Node

# 封装终端指令相关类......

# from launch.actions import ExecuteProcess

# from launch.substitutions import FindExecutable

# 参数声明与获取......

# from launch.actions import DeclareLaunchArgument

# from launch.substitutions import LaunchConfiguration

# 文件包含相关......

from launch.actions import IncludeLaunchDescription

from launch.launch_description_sources import PythonLaunchDescriptionSource

# 分组相关......

# from launch_ros.actions import PushRosNamespace

# from launch.actions import GroupAction

# 事件相关......

# from launch.event_handlers import OnProcessStart, OnProcessExit

# from launch.actions import RegisterEventHandler

# from launch.actions import LogInfo

# 获取功能包下share目录路径......

from ament_index_python.packages import get_package_share_directory

import os

  

"""

启动驱动

加载位置获取节点

"""

  

def generate_launch_description():

go2_driver_pkg = get_package_share_directory("go2_driver_py")

go2_driver_launch = IncludeLaunchDescription(

launch_description_source=PythonLaunchDescriptionSource(

launch_file_path=os.path.join(go2_driver_pkg,"launch","driver.launch.py")

)

)

return LaunchDescription([

go2_driver_launch,

Node(

package="go2_tutorial_py",

executable="go2_state",

parameters=[os.path.join(get_package_share_directory("go2_tutorial_py"),"params","go2_state.yaml")],

)

])
```
5. go2_tutorial 下创建 go2_state.py:
```
"""

需求：订阅里程计消息，当机器人位移超过阈值，输出当前坐标

实现流程：

1.订阅里程计消息

2.在订阅方的回调函数中，计算当前机器人位置与上一个记录点的距离，

如果大于阈值就输出坐标并更新

3.生成第一个记录点

当第一次订阅里程计消息时，就为记录点赋值

"""

  

import rclpy

from rclpy.node import Node

from nav_msgs.msg import Odometry

import math

  

class Go2State(Node):

def __init__(self):

super().__init__('go2_state')

# 第一次过去里程计消息的标记

self.is_first = True

# 记录点坐标对应的变量

self.last_x = 0.0

self.last_y = 0.0

# 阈值参数

self.declare_parameter("distance",0.5)

  

self.odom_sub = self.create_subscription(Odometry,"odom",self.odom_cb,10)

def odom_cb(self,odom : Odometry):

# 获取当前坐标

x = odom.pose.pose.position.x

y = odom.pose.pose.position.y

# 设置第一个记录点

if self.is_first:

self.last_x = x

self.last_y = y

self.is_first = False

self.get_logger().info("原点坐标:(%.2f,%.2f)" % (x,y))

return

# 计算是否超出距离

dis_x = x - self.last_x

dis_y = y - self.last_y

  

distance = math.sqrt(dis_x**2 + dis_y**2)

# 判断

if distance >= self.get_parameter("distance").value:

# 输出坐标点

self.get_logger().info("坐标:(%.2f,%.2f)" % (x,y))

# 记录点数据更新

self.last_x = x

self.last_y = y

  
  

def main():

rclpy.init()

rclpy.spin(Go2State())

rclpy.shutdown()

  

if __name__ == '__main__':

main()
```
6. params 下创建 go2_state.yaml :
获取参数：`ros2 param dump /go2_state `
```
/**:

ros__parameters:

distance: 0.3

use_sim_time: false
```