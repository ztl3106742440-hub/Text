colcon build --packages-select go2_tutorial
. install/setup.bash
ros2 launch go2_tutorial go2_cruising.launch.py
开始：
ros2 run go2_tutorial go2_cruising_client 1
停止：
ros2 run go2_tutorial go2_cruising_client 0


ros2 service call /cruising go2_tutorial_inter/srv/Cruising "{flag: 1}"



1. psckage.xml:
```
<depend>geometry_msgs</depend>
<depend>ros2_tutorial_inter</depend>
```
2. cmakelist.txt
```
# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(unitree_go REQUIRED)
find_package(unitree_api REQUIRED)
find_package(nav_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(go2_tutorial_inter REQUIRED)

add_executable(go2_ctrl src/go2_ctrl.cpp)
add_executable(go2_state src/go2_state.cpp)
add_executable(go2_cruising_service src/go2_cruising_service.cpp)
add_executable(go2_cruising_client src/go2_cruising_client.cpp)

target_include_directories(go2_ctrl PUBLIC
$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
$<INSTALL_INTERFACE:include>)

target_include_directories(go2_cruising_service PUBLIC
$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
$<INSTALL_INTERFACE:include>)

target_compile_features(go2_ctrl PUBLIC c_std_99 cxx_std_17) # Require C99 and C++17
ament_target_dependencies(
go2_ctrl
"rclcpp"
"unitree_go"
"unitree_api"
)

ament_target_dependencies(
go2_state
"rclcpp"
"unitree_go"
"unitree_api"
"nav_msgs"
)

ament_target_dependencies(
go2_cruising_service
"rclcpp"
"unitree_go"
"unitree_api"
"nav_msgs"
"geometry_msgs"
"go2_tutorial_inter"
)

ament_target_dependencies(
go2_cruising_client
"rclcpp"
"unitree_go"
"unitree_api"
"nav_msgs"
"geometry_msgs"
"go2_tutorial_inter"
)

install(TARGETS go2_ctrl
DESTINATION lib/${PROJECT_NAME})

install(TARGETS go2_state
DESTINATION lib/${PROJECT_NAME})
  
install(TARGETS go2_cruising_service
DESTINATION lib/${PROJECT_NAME})

install(TARGETS go2_cruising_client
DESTINATION lib/${PROJECT_NAME})

install(DIRECTORY launch params
DESTINATION share/${PROJECT_NAME})
```
3. go2_tutorial/src 下创建go2_cruising_service.cpp ; 
```
/*

需求：处理客户端提交的数据（0或非0）。

如果是0,停止巡航；非0,开始巡航。

不管提交什么数据都要相应机器人位置信息

流程：

1.创建服务器

2.回调函数处理请求，分情况处理（控制机器人巡航），最后响应结果。

*/

#include "rclcpp/rclcpp.hpp"

#include "go2_tutorial_inter/srv/cruising.hpp"

#include "geometry_msgs/msg/point.hpp"

#include "nav_msgs/msg/odometry.hpp"

#include "sport_model.hpp"

  

using namespace std::chrono_literals;

using namespace std::placeholders;

class Go2SCruisingService : public rclcpp::Node

{

public:

Go2SCruisingService() : Node("go2_cruising_service")

{

// 构造函数：初始化发布者、订阅者、服务等

RCLCPP_INFO(this->get_logger(), "Hello from my ROS 2 node!");

this->declare_parameter("x",0.1);

this->declare_parameter("y",0.0);

this->declare_parameter("z",0.5);

// 创建远程参数客户端

param_client_ = std::make_shared<rclcpp::AsyncParametersClient>(this,"go2_ctrl");

// 客户端连接到服务端

while (!param_client_->wait_for_service(1s))

{

if (!rclcpp::ok())

{

return;

}

RCLCPP_INFO(this->get_logger(),"服务连接中......");

}

RCLCPP_INFO(this->get_logger(),"成功连接到参数服务器!");

// 通过订阅里程计获取机器人信息

odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>("odom",10,std::bind(&Go2SCruisingService::odom_cb,this,_1));

// 创建服务器

cru_service_ = this->create_service<go2_tutorial_inter::srv::Cruising>("cruising",std::bind(&Go2SCruisingService::cru_cb,this,_1,_2));

}

  

private:

// 成员变量（如发布者、订阅者）声明

rclcpp::AsyncParametersClient::SharedPtr param_client_;

rclcpp::Service<go2_tutorial_inter::srv::Cruising>::SharedPtr cru_service_;

rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;

geometry_msgs::msg::Point current_point;

// 实时获取机器人位置

void odom_cb(const nav_msgs::msg::Odometry::SharedPtr odom){

current_point = odom->pose.pose.position;

}

void cru_cb(const go2_tutorial_inter::srv::Cruising::Request::SharedPtr request,

const go2_tutorial_inter::srv::Cruising::Response::SharedPtr response){

// 处理请求

auto flag = request->flag;

// 向 go2_ctrl 节点注入参数,如果是0,那么api_id = stopmove, 否则 = move

int32_t id;

if (flag != 0)

{

id = ROBOT_SPORT_API_ID_MOVE;

RCLCPP_INFO(this->get_logger(),"开始巡航......");

}else {

id = ROBOT_SPORT_API_ID_STOPMOVE;

RCLCPP_INFO(this->get_logger(),"结束巡航......");

}

// 向巡航节点注入参数

param_client_->set_parameters({

// rclcpp::Parameter("x",0.1),

// rclcpp::Parameter("y",0.0),

// rclcpp::Parameter("z",0.5),

this->get_parameter("x"),

this->get_parameter("y"),

this->get_parameter("z"),

rclcpp::Parameter("sport_api_id",id),

});

// 生成响应

response->point = current_point;

}

  

};

  

int main(int argc, char ** argv)

{

// 初始化 ROS 2

rclcpp::init(argc, argv);

// 创建节点并开始自旋（处理回调）

auto node = std::make_shared<Go2SCruisingService>();

rclcpp::spin(node);

// 关闭 ROS 2

rclcpp::shutdown();

return 0;

}
```

4. go2_tutorial/src 下创建go2_cruising_client.cpp；
```
/*

需求:客户端向服务端发送整型数据,并接收服务器的响应结果.

流程:

1.判断提交的数据是否合法;

2.ROS2初始化;

3.创建自定义节点类对象;

4.连接服务端;

5.向服务端发送数据;

6.处理响应结果;

7.资源释放.

*/

#include "rclcpp/rclcpp.hpp"

#include "go2_tutorial_inter/srv/cruising.hpp"

  

using namespace std::chrono_literals;

class Go2SCruisingClient : public rclcpp::Node

{

public:

Go2SCruisingClient() : Node("go2_cruising_client")

{

// 构造函数：初始化发布者、订阅者、服务等

RCLCPP_INFO(this->get_logger(), "Hello from my ROS 2 node!");

cru_client_ = this->create_client<go2_tutorial_inter::srv::Cruising>("cruising");

}

// 连接服务端

bool connect_server(){

while (!cru_client_->wait_for_service(1s))

{

if (!rclcpp::ok())

{

return false;

}

RCLCPP_INFO(this->get_logger(),"服务连接中...");

}

return true;

}

// 发送请求并返回响应结果

rclcpp::Client<go2_tutorial_inter::srv::Cruising>::FutureAndRequestId send_requrst(int32_t flag){

auto req_ = std::make_shared<go2_tutorial_inter::srv::Cruising_Request>();

req_->flag = flag;

return cru_client_->async_send_request(req_);

}

  

private:

// 成员变量（如发布者、订阅者）声明

rclcpp::Client<go2_tutorial_inter::srv::Cruising>::SharedPtr cru_client_;

};

  

int main(int argc, char ** argv)

{

if (argc != 2)

{

RCLCPP_ERROR(rclcpp::get_logger("rclcpp"),"请提交一个整形数据");

return 1;

}

// 初始化 ROS 2

rclcpp::init(argc, argv);

// 创建节点

auto client_ = std::make_shared<Go2SCruisingClient>();

// 连接服务器

auto flag = client_->connect_server();

// 连接成功后向服务器发送数据

if (!flag)

{

return 1;

}

auto response_future = client_->send_requrst(atoi(argv[1]));

// 处理响应结果

if (rclcpp::spin_until_future_complete(client_,response_future) == rclcpp::FutureReturnCode::SUCCESS){

RCLCPP_INFO(rclcpp::get_logger("rclcpp"),"响应成功");

auto response_ = response_future.get();

RCLCPP_INFO(rclcpp::get_logger("rclcpp"),"机器人坐标:(%.2f,%.2f)",response_->point.x,response_->point.y);

}else {

RCLCPP_INFO(rclcpp::get_logger("rclcpp"),"响应失败");

}

//释放资源

  
  

// 创建节点并开始自旋（处理回调）

// auto node = std::make_shared<Go2SCruisingClient>();

// rclcpp::spin(node);

// 关闭 ROS 2

rclcpp::shutdown();

return 0;

}
```

5. go2_tutorial/launch 下创建 go2_cruising.launch.py 
```
from launch import LaunchDescription

from launch_ros.actions import Node

# 封装终端指令相关类......

# from launch.actions import ExecuteProcess

# from launch.substitutions import FindExecutable

# 参数声明与获取......

# from launch.actions import DeclareLaunchArgument

# from launch.substitutions import LaunchConfiguration

# 文件包含相关......

from launch.actions import IncludeLaunchDescription

from launch.launch_description_sources import PythonLaunchDescriptionSource

# 分组相关......

# from launch_ros.actions import PushRosNamespace

# from launch.actions import GroupAction

# 事件相关......

# from launch.event_handlers import OnProcessStart, OnProcessExit

# from launch.actions import RegisterEventHandler

# from launch.actions import LogInfo

# 获取功能包下share目录路径......

from ament_index_python.packages import get_package_share_directory

import os

  

def generate_launch_description():

  

go2_driver_pkg = get_package_share_directory("go2_driver")

# 包含驱动

go2_driver_launch = IncludeLaunchDescription(

launch_description_source=PythonLaunchDescriptionSource(

launch_file_path=os.path.join(go2_driver_pkg,"launch","driver.launch.py")

)

)

# 包含巡航

go2_tutorial_pkg = get_package_share_directory("go2_tutorial")

go2_ctrl_launch = IncludeLaunchDescription(

launch_description_source=PythonLaunchDescriptionSource(

launch_file_path=os.path.join(go2_tutorial_pkg,"launch","go2_ctrl.launch.py")

)

)

  

# 包含巡航启动服务端；客户端需要单独调用

cru_service_node = Node(

package="go2_tutorial",

executable="go2_cruising_service",

parameters=[os.path.join(go2_tutorial_pkg,"params","go2_cruising_service.yaml")]

)

  

return LaunchDescription([

go2_driver_launch,

go2_ctrl_launch,

cru_service_node,

])
```

6. params 下创建 go2_cruising_service.yaml
查询参数: ros2 param dump /go2_cruising_service

