colcon build --packages-select go2_tutorial_py
. install/setup.bash
ros2 launch go2_tutorial_py go2_cruising.launch.py
开始：
ros2 run go2_tutorial_py go2_cruising_client 1
停止：
ros2 run go2_tutorial_py go2_cruising_client 0

ros2 service call /cruising go2_tutorial_inter/srv/Cruising "{flag: 1}"


1. go2_tutorial_py/go2_tutorial_py 下创建go2_cruising_service.py
```
"""

需求：处理客户端提交的数据（0或非0）。

如果是0,停止巡航；非0,开始巡航。

不管提交什么数据都要相应机器人位置信息

流程：

1.创建服务器

2.回调函数处理请求，分情况处理（控制机器人巡航），最后响应结果。

"""

import rclpy

from rclpy.node import Node

from go2_tutorial_inter.srv import Cruising

from geometry_msgs.msg import Point

from nav_msgs.msg import Odometry

from unitree_api.msg import Request

from .sport_model import ROBOT_SPORT_API_IDS

import json

  

class Go2CruisingService(Node):

def __init__(self):

super().__init__('go2_cruising_service')

# 创建服务器

self.service = self.create_service(Cruising,"cruising",self.cru_cb)

# 创建空point

self.point = Point()

# 订阅里程计数据

self.odom_sub = self.create_subscription(Odometry,"odom",self.odom_cb,10)

# 设置巡航参数

self.declare_parameter("x",0.0)

self.declare_parameter("y",0.0)

self.declare_parameter("z",0.5)

# 创建速度控制的发布对象

self.api_id = ROBOT_SPORT_API_IDS["BALANCESTAND"]

self.req_pub = self.create_publisher(Request,"/api/sport/request",10)

self.timer = self.create_timer(0.1,self.on_timer)

  

def on_timer(self):

req = Request()

# 设置数据

req.header.identity.api_id = self.api_id

# 设置参数

js = {

"x": self.get_parameter("x").value,

"y": self.get_parameter("y").value,

"z": self.get_parameter("z").value,

}

req.parameter = json.dumps(js)

self.req_pub.publish(req)

  

def cru_cb(self,request : Cruising.Request, response : Cruising.Response):

# 处理请求

flag = request.flag

  

if flag == 0:

self.get_logger().info("结束巡航")

self.api_id = ROBOT_SPORT_API_IDS["STOPMOVE"]

else:

self.get_logger().info("开始巡航")

self.api_id = ROBOT_SPORT_API_IDS["MOVE"]

  

# 产生响应

response.point = self.point

return response

# 里程计回调函数

def odom_cb(self, odom : Odometry):

self.point = odom.pose.pose.position

  

def main():

rclpy.init()

rclpy.spin(Go2CruisingService())

rclpy.shutdown()

  

if __name__ == '__main__':

main()
```

2. go2_tutorial_py/go2_tutorial_py 下创建go2_cruising_client.py
```
"""

需求:客户端向服务端发送整型数据,并接收服务器的响应结果.

流程:

1.判断提交的数据是否合法;

2.ROS2初始化;

3.创建自定义节点类对象;

4.连接服务端;

5.向服务端发送数据;

6.处理响应结果;

7.资源释放.

"""

import rclpy

from rclpy.node import Node

from rclpy.logging import get_logger

import sys

from go2_tutorial_inter.srv import Cruising

from rclpy.task import Future

  

class Go2CruisingClient(Node):

def __init__(self):

super().__init__('go2_cruising_client')

# 在这里添加初始化代码

self.client = self.create_client(Cruising,"cruising")

  

def connect_server(self):

while not self.client.wait_for_service(1.0):

if not rclpy.ok():

get_logger("rclpy").error("连接被中断")

return False

self.get_logger().info("服务器连接中...")

return True

def send_request(self,flag) -> Future:

# 组织数据

req = Cruising.Request()

req.flag = int(flag)

# 发送请求

return self.client.call_async(req)

  

def main():

# 判断提交的数据是否合法;

if len(sys.argv) != 2:

get_logger("rclpy").error("请提交一个整型数据！")

return

# ROS2初始化;

rclpy.init()

# 创建自定义节点类对象;

cru_client = Go2CruisingClient()

# 连接服务端;

flag = cru_client.connect_server()

if not flag:

return

# 向服务端发送数据;

future = cru_client.send_request(sys.argv[1])

# 处理响应结果;

rclpy.spin_until_future_complete(cru_client,future)

if future.done():

response : Cruising.Response = future.result()

get_logger("rclpy").info("机器人坐标：(%.2f,%.2f)" % (response.point.x, response.point.y))

else:

get_logger("rclpy").info("请求失败！")

# 资源释放.

# rclpy.init()

# rclpy.spin(Go2CruisingClient())

rclpy.shutdown()

  

if __name__ == '__main__':

main()
```

3. setup.py:
```
entry_points={

'console_scripts': [

'go2_ctrl = go2_tutorial_py.go2_ctrl:main',

'go2_state = go2_tutorial_py.go2_state:main',

'go2_cruising_service = go2_tutorial_py.go2_cruising_service:main',

'go2_cruising_client = go2_tutorial_py.go2_cruising_client:main',

],

},
```
4. package.xml:
```
<depend>geometry_msgs</depend>
<depend>go2_tutorial_inter</depend>
```

5. launch 下创建 go2_cruising.launch.py
```
from launch import LaunchDescription

from launch_ros.actions import Node

# 封装终端指令相关类......

# from launch.actions import ExecuteProcess

# from launch.substitutions import FindExecutable

# 参数声明与获取......

# from launch.actions import DeclareLaunchArgument

# from launch.substitutions import LaunchConfiguration

# 文件包含相关......

from launch.actions import IncludeLaunchDescription

from launch.launch_description_sources import PythonLaunchDescriptionSource

# 分组相关......

# from launch_ros.actions import PushRosNamespace

# from launch.actions import GroupAction

# 事件相关......

# from launch.event_handlers import OnProcessStart, OnProcessExit

# from launch.actions import RegisterEventHandler

# from launch.actions import LogInfo

# 获取功能包下share目录路径......

from ament_index_python.packages import get_package_share_directory

import os

  

def generate_launch_description():

  

go2_driver_pkg = get_package_share_directory("go2_driver_py")

# 包含驱动

go2_driver_launch = IncludeLaunchDescription(

launch_description_source=PythonLaunchDescriptionSource(

launch_file_path=os.path.join(go2_driver_pkg,"launch","driver.launch.py")

)

)

# 包含巡航

go2_tutorial_pkg = get_package_share_directory("go2_tutorial_py")

# go2_ctrl_launch = IncludeLaunchDescription(

# launch_description_source=PythonLaunchDescriptionSource(

# launch_file_path=os.path.join(go2_tutorial_pkg,"launch","go2_ctrl.launch.py")

# )

# )

  

# 包含巡航启动服务端；客户端需要单独调用

cru_service_node = Node(

package="go2_tutorial_py",

executable="go2_cruising_service",

parameters=[os.path.join(go2_tutorial_pkg,"params","go2_cruising_service.yaml")]

)

  

return LaunchDescription([

go2_driver_launch,

# go2_ctrl_launch,

cru_service_node,

])
```

6. params 下创建 go2_cruising_service.yaml
查询参数：ros2 param dump /go2_cruising_service
```
/**:
ros__parameters:
use_sim_time: false
x: 0.1
y: 0.0
z: 0.5
```
