构建inter/action:
```
colcon build --packages-select go2_tutorial_inter
. install/setup.bash
ros2 interface show go2_tutorial_inter/action/Nav
```

运行
```
colcon build --packages-select go2_tutorial
. install/setup.bash
ros2 launch go2_tutorial go2_nav.launch.py

另一个终端
. install/setup.bash
ros2 run go2_tutorial go2_nav_client 1.0
```
ros2 run go2_tutorial go2_nav_server
ros2 run go2_tutorial go2_nav_client 1.0

. install/setup.bash
ros2 action list
ros2 action send_goal /nav go2_tutorial_inter/action/Nav "{goal: 1.0}" -f



1. go2_tutorial_inter 下创建 action 文件夹，并创建 Nav.action 文件
```
# 请求数据（前进距离）
float32 goal
---
# 最终响应（坐标）
geometry_msgs/Point point
---
# 连续反馈（剩余距离）
float32 distance
```
2. go2_tutorial_inter/package:
```
<buildtool_depend>ament_cmake</buildtool_depend>
<depend>geometry_msgs</depend>
<build_depend>rosidl_default_generators</build_depend>
<buildtool_depend>rosidl_default_generators</buildtool_depend>
<exec_depend>rosidl_default_runtime</exec_depend>
<member_of_group>rosidl_interface_packages</member_of_group>
<depend>action_msgs</depend>
```
3. go2_tutorial_inter/cmakelist.txt:
```
rosidl_generate_interfaces(${PROJECT_NAME}
"srv/Cruising.srv"
"action/Nav.action"
DEPENDENCIES "geometry_msgs"
)
```
4. go2_tutorial/src 创建 go2_nav_server
```
/*

导航服务端

需求：

1.处理客户端需求

提交的请求为浮点数（前进距离）

如果大于0,则前进；否则认为不合法

2.处理客户端取消请求

当客户端发送取消请求，则让机器人停止

3.产生连续反馈和最终响应

根据机器人当前坐标，结合起点坐标与前进距离，计算剩余距离并周期性反馈

当机器人到达目标点，响应机器人坐标

实现：

1.创建action服务器，执行相关操作；

2.向 go2_ctrl 注入参数控制机器人运动或停止；

3.订阅机器人里程计获取坐标。

*/

#include "rclcpp/rclcpp.hpp"

#include "rclcpp_action/rclcpp_action.hpp"

#include "go2_tutorial_inter/action/nav.hpp"

#include "nav_msgs/msg/odometry.hpp"

#include "geometry_msgs/msg/point.hpp"

#include "sport_model.hpp"

  

using namespace rclcpp_action;

using namespace std::placeholders;

using namespace std::chrono_literals;

class Go2NavServer : public rclcpp::Node

{

public:

Go2NavServer() : Node("go2_nav_server")

{

// 构造函数：初始化发布者、订阅者、服务等

RCLCPP_INFO(this->get_logger(), "Hello from my ROS 2 node!");

this->declare_parameter("x",0.1);

this->declare_parameter("error",0.2);

// 创建客户端参数，用于向 go2_ctrl 注入参数

param_client_ = std::make_shared<rclcpp::AsyncParametersClient>(this,"go2_ctrl");

// 连接参数服务

while (!param_client_->wait_for_service(1s))

{

// ctrl + c 连接超时，退出

if(!rclcpp::ok()){

return;

}

RCLCPP_INFO(this->get_logger(),"参数服务连接中...");

}

  

// 创建里程计订阅对象

odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>("odom",10,std::bind(&Go2NavServer::odom_cb,this,_1));

  

// 创建导航服务端

nav_server_ = rclcpp_action::create_server<go2_tutorial_inter::action::Nav>(

this,

"nav",

std::bind(&Go2NavServer::goal_cb,this,_1,_2),

std::bind(&Go2NavServer::cancel_cb,this,_1),

std::bind(&Go2NavServer::accepted_cb,this,_1)

);

}

  

private:

// 参数客户端

rclcpp::AsyncParametersClient::SharedPtr param_client_;

// 成员变量（如发布者、订阅者）声明

rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;

rclcpp_action::Server<go2_tutorial_inter::action::Nav>::SharedPtr nav_server_;

geometry_msgs::msg::Point current_point,start_point;

  

// 订阅里程计消息

void odom_cb(const nav_msgs::msg::Odometry::SharedPtr odom_){

// 实时获取机器人坐标

current_point = odom_->pose.pose.position;

}

  

// /// Signature of a callback that accepts or rejects goal requests.

// using GoalCallback = std::function<GoalResponse(

// const GoalUUID &, std::shared_ptr<const typename ActionT::Goal>)>;

GoalResponse goal_cb(const GoalUUID &uuid, std::shared_ptr<const go2_tutorial_inter::action::Nav::Goal> goal){

(void)uuid;

// 获取前进距离

float goal_dis = goal->goal;

// 判断合法性

// 合法则控制机器人前进，否则拒绝任务

if (goal_dis > 0.0)

{

RCLCPP_INFO(this->get_logger(),"前进%.2f米",goal_dis);

start_point = current_point;

// 让 go2 运动

param_client_->set_parameters({

rclcpp::Parameter("sport_api_id",ROBOT_SPORT_API_ID_MOVE),

this->get_parameter("x")

});

  

return GoalResponse::ACCEPT_AND_EXECUTE;

}else {

RCLCPP_ERROR(this->get_logger(),"前进%.2f米,距离小于0,非法数据！",goal_dis);

return GoalResponse::REJECT;

}

  

}

// /// Signature of a callback that accepts or rejects requests to cancel a goal.

// using CancelCallback = std::function<CancelResponse(std::shared_ptr<ServerGoalHandle<ActionT>>)>;

// 处理客户端提交的取消请求

CancelResponse cancel_cb(std::shared_ptr<ServerGoalHandle<go2_tutorial_inter::action::Nav>> server_goal_handle){

(void)server_goal_handle;

//

RCLCPP_INFO(this->get_logger(),"取消任务！");

// 让机器狗停止运动

stop_move();

// 无条件接收取消请求

return CancelResponse::ACCEPT;

}

void stop_move(){

param_client_->set_parameters({

rclcpp::Parameter("sport_api_id",ROBOT_SPORT_API_ID_STOPMOVE),

rclcpp::Parameter("x",0.0),

rclcpp::Parameter("y",0.0),

rclcpp::Parameter("z",0.0),

});

}

// /// Signature of a callback that is used to notify when the goal has been accepted.

// using AcceptedCallback = std::function<void (std::shared_ptr<ServerGoalHandle<ActionT>>)>;

// 主逻辑

void accepted_cb (std::shared_ptr<ServerGoalHandle<go2_tutorial_inter::action::Nav>> server_goal_handle){

std::thread(std::bind(&Go2NavServer::execute,this,_1),server_goal_handle).detach();

}

void execute(std::shared_ptr<ServerGoalHandle<go2_tutorial_inter::action::Nav>> server_goal_handle){

//

auto feedback = std::make_shared<go2_tutorial_inter::action::Nav::Feedback>();

auto result = std::make_shared<go2_tutorial_inter::action::Nav::Result>();

// 1.生成连续反馈

rclcpp::Rate rate(1.0);

while (rclcpp::ok())

{

// 生成剩余距离 --- 获取当前坐标点和起点 --- 剩余距离 = 目标距离- 已行进距离

auto dis_x = current_point.x - start_point.x;

auto dis_y = current_point.y - start_point.y;

auto dis = sqrt(pow(dis_x,2) + pow(dis_y,2));

auto distance = server_goal_handle->get_goal()->goal - dis;

// 发布剩余距离

feedback->distance = distance;

server_goal_handle->publish_feedback(feedback);

// 循环退出条件

// 任务被取消（客户端提交取消任务请求）

if (server_goal_handle->is_canceling())

{

// 停止运动

stop_move();

// 响应结果

result->point = current_point;

server_goal_handle->canceled(result);

return;

}

  

// 任务已完成（到达目标点附近）

if (distance <= this->get_parameter("error").as_double())

{

RCLCPP_INFO(this->get_logger(),"已经到达目标点附近!");

stop_move();

break;

}

rate.sleep();

}

// 2.生成最终结果

if (rclcpp::ok())

{

result->point = current_point;

server_goal_handle->succeed(result);

}

  

}

  
  

};

  

int main(int argc, char ** argv)

{

// 初始化 ROS 2

rclcpp::init(argc, argv);

// 创建节点并开始自旋（处理回调）

auto node = std::make_shared<Go2NavServer>();

rclcpp::spin(node);

// 关闭 ROS 2

rclcpp::shutdown();

return 0;

}
```




5. go2_tutorial/src 创建 go2_nav_client
```
/*

导航客户端

需求：

客户端发送数据到服务端，并发送服务端的响应结果

流程：

1.判断程序执行时参数个数是否合法；

2.初始化 ROS2；

3.创建action客户端对象；

4.连接服务器；

5.发送请求数据并处理响应结果。若连接失败，直接退出。

6.调用 spin 函数，并传入节点对象指针；

7.释放资源。

*/

#include "rclcpp/rclcpp.hpp"

#include "rclcpp_action/rclcpp_action.hpp"

#include "go2_tutorial_inter/action/nav.hpp"

  

using namespace std::chrono_literals;

using namespace std::placeholders;

class Go2NavClient : public rclcpp::Node

{

public:

// 注意构造函数

Go2NavClient(const rclcpp::NodeOptions & options = rclcpp::NodeOptions()) : Node("go2_nav_client",options)

{

// 构造函数：初始化发布者、订阅者、服务等

RCLCPP_INFO(this->get_logger(), "Hello from my ROS 2 node!");

client_ = rclcpp_action::create_client<go2_tutorial_inter::action::Nav>(this,"nav");

}

bool connect_server(){

while (!client_->wait_for_action_server(1s))

{

RCLCPP_INFO(rclcpp::get_logger("rclcpp"),"服务器连接中...");

if (!rclcpp::ok())

{

return false;

}

}

return true;

}

void send_request(float x){

// 组织数据

go2_tutorial_inter::action::Nav::Goal goal;

goal.goal = x;

// 发送 + 处理响应

rclcpp_action::Client<go2_tutorial_inter::action::Nav>::SendGoalOptions options;

// 目标值回调函数

options.goal_response_callback = std::bind(&Go2NavClient::goal_response_callback,this,_1);

// 连续反馈回调函数

options.feedback_callback = std::bind(&Go2NavClient::feedback_callback,this,_1,_2);

// 最终响应回调函数

options.result_callback = std::bind(&Go2NavClient::result_callback,this,_1);

client_->async_send_goal(goal,options);

}

// 析构--停止

~Go2NavClient(){

client_->async_cancel_all_goals();

}

private:

// 成员变量（如发布者、订阅者）声明

rclcpp_action::Client<go2_tutorial_inter::action::Nav>::SharedPtr client_;

  

void goal_response_callback(std::shared_ptr<rclcpp_action::ClientGoalHandle<go2_tutorial_inter::action::Nav>> goal_handle){

if (goal_handle)

{

RCLCPP_INFO(this->get_logger(),"目标请求被接收");

}else{

RCLCPP_ERROR(this->get_logger(),"目标值非法");

rclcpp::shutdown();

}

}

void feedback_callback(rclcpp_action::ClientGoalHandle<go2_tutorial_inter::action::Nav>::SharedPtr goal_handle,

const std::shared_ptr<const go2_tutorial_inter::action::Nav::Feedback> feedback){

(void)goal_handle;

RCLCPP_INFO(this->get_logger(),"距离目标点还有%.2f米",feedback->distance);

}

void result_callback(const rclcpp_action::ClientGoalHandle<go2_tutorial_inter::action::Nav>::WrappedResult &result){

switch (result.code)

{

case rclcpp_action::ResultCode::SUCCEEDED:

RCLCPP_INFO(this->get_logger(),"机器人的停止坐标：(%.2f,%.2f)",result.result->point.x,result.result->point.y);

break;

case rclcpp_action::ResultCode::CANCELED:

RCLCPP_INFO(this->get_logger(),"任务被取消！");

break;

default:

RCLCPP_INFO(this->get_logger(),"未知异常！");

break;

}

rclcpp::shutdown();

}

};

  

int main(int argc, char ** argv)

{

// 判断程序执行时参数个数是否合法；

if (argc != 2)

{

RCLCPP_ERROR(rclcpp::get_logger("rclcpp"),"请提交一个整型的数据！");

return 1;

}

// 初始化 ROS 2

rclcpp::init(argc, argv);

// 创建节点并开始自旋（处理回调）

auto nav_client = std::make_shared<Go2NavClient>();

// 连接服务端

auto flag = nav_client->connect_server();

  

// 发送请求数据并处理响应结果。若连接失败，直接退出。

if (!flag)

{

RCLCPP_ERROR(rclcpp::get_logger("rclcpp"),"服务连接失败！");

return 1;

}

  

nav_client->send_request(atof(argv[1]));

  

rclcpp::spin(nav_client);

// 关闭 ROS 2

rclcpp::shutdown();

return 0;

}
```





6. go2_tutorial/package: `<depend>rclcpp_action</depend>`
7.  go2_tutorial/cmakelist.txt:
```
find_package(rclcpp_action REQUIRED)


add_executable(go2_nav_client src/go2_nav_client.cpp)
add_executable(go2_nav_server src/go2_nav_server.cpp)


target_include_directories(go2_nav_server PUBLIC
$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
$<INSTALL_INTERFACE:include>)


ament_target_dependencies(
go2_nav_server
"rclcpp"
"unitree_go"
"unitree_api"
"nav_msgs"
"geometry_msgs"
"go2_tutorial_inter"
"rclcpp_action"
)
ament_target_dependencies(
go2_nav_client
"rclcpp"
"unitree_go"
"unitree_api"
"nav_msgs"
"geometry_msgs"
"go2_tutorial_inter"
"rclcpp_action"
)


install(TARGETS go2_nav_server
DESTINATION lib/${PROJECT_NAME})

install(TARGETS go2_nav_client
DESTINATION lib/${PROJECT_NAME})
```
8. go2_tutorial/launch 创建 go2_nav.launch.py:
复制 go2_cruising.launch.py
更改命名：
```
# 包含导航服务端；客户端需要单独调用
nav_server_node = Node(
package="go2_tutorial",
executable="go2_nav_server",
# parameters=[os.path.join(go2_tutorial_pkg,"params","go2_nav_server.yaml")]
)

return LaunchDescription([
go2_driver_launch,
go2_ctrl_launch,
nav_server_node,
])
```
9. go2_tutorial/params 创建 go2_anv.yaml
`ros2 param dump /go2_nav_server`
```
/**:
ros__parameters:
error: 0.2
use_sim_time: false
x: 0.5
```
