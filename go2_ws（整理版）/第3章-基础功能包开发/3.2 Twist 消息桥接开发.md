# 3.2 Twist 消息桥接开发

## 学习目标
- 理解 ROS2 标准消息接口的重要性
- 掌握消息类型转换的实现方法
- 实现 Twist 到 Request 的消息桥接
- 学会使用 teleop_twist_keyboard 控制 Go2

---

## 一、功能简介与需求分析

### 1.1 为什么需要 Twist 桥接？

**问题**：
- Go2 使用专有的 `unitree_api/msg/Request` 消息
- ROS2 生态使用标准的 `geometry_msgs/msg/Twist` 消息
- 很多工具（导航、键盘控制等）只发布 Twist 消息

**解决方案**：
开发一个**消息桥接节点**，将 Twist 消息转换为 Request 消息。

```
标准工具                桥接节点                 Go2
─────────          ─────────────          ─────────
teleop_twist  →    Twist → Request   →   /api/sport/request
navigation    →    消息转换           →   机器狗执行
keyboard      →                       →
```

### 1.2 消息结构对比

**Twist 消息**（标准）：
```
geometry_msgs/Twist
├── linear
│   ├── x    # 前后速度 (m/s)
│   ├── y    # 左右速度 (m/s)
│   └── z    # 上下速度 (通常不用)
└── angular
    ├── x    # 横滚 (通常不用)
    ├── y    # 俯仰 (通常不用)
    └── z    # 偏航速度 (rad/s)
```

**Request 消息**（Go2专用）：
```
unitree_api/Request
├── header
│   └── identity
│       └── api_id    # 1008 = MOVE
└── parameter         # JSON: '{"x":0.1,"y":0.0,"z":0.5}'
```

### 1.3 转换逻辑

| Twist 字段 | → | Request 参数 |
|-----------|---|-------------|
| `linear.x` | → | `JSON["x"]` |
| `linear.y` | → | `JSON["y"]` |
| `angular.z` | → | `JSON["z"]` |

---

## 二、创建功能包

### 2.1 C++ 版本

```bash
cd ~/unitree_go2_ws/src/base

ros2 pkg create go2_twist_bridge \
    --build-type ament_cmake \
    --dependencies rclcpp geometry_msgs unitree_api \
    --node-name twist_bridge
```

### 2.2 Python 版本

```bash
ros2 pkg create go2_twist_bridge_py \
    --build-type ament_python \
    --dependencies rclpy geometry_msgs unitree_api \
    --node-name twist_bridge
```

---

## 三、C++ 实现

### 3.1 准备 sport_model.hpp

在 `go2_twist_bridge/include/` 创建 `sport_model.hpp`：

```cpp
#ifndef _SPORT_MODEL_
#define _SPORT_MODEL_

// Go2 运动控制 API ID 定义
const int32_t ROBOT_SPORT_API_ID_BALANCESTAND = 1002;  // 平衡站立
const int32_t ROBOT_SPORT_API_ID_STOPMOVE = 1003;      // 停止运动
const int32_t ROBOT_SPORT_API_ID_MOVE = 1008;          // 移动

#endif
```

> **说明**：也可以从 `~/unitree_ros2/example/src/include/` 复制 nlohmann 库。

### 3.2 编写twist_bridge.cpp

打开 `src/twist_bridge.cpp`：

```cpp
/*
功能：Twist 消息桥接
将 geometry_msgs/Twist 转换为 unitree_api/Request

实现步骤：
1. 创建 Request 发布者
2. 创建 Twist 订阅者
3. 在回调函数中转换消息并发布
*/

#include "rclcpp/rclcpp.hpp"
#include "unitree_api/msg/request.hpp"
#include "geometry_msgs/msg/twist.hpp"
#include "sport_model.hpp"
#include "nlohmann/json.hpp"

using namespace std::placeholders;

class TwistBridge : public rclcpp::Node
{
public:
    TwistBridge() : Node("twist_bridge")
    {
        RCLCPP_INFO(this->get_logger(),
            "Twist 桥接节点启动：将 geometry_msgs/Twist 转换为 unitree_api/Request");

        // 1. 创建 Request 发布者
        request_pub_ = this->create_publisher<unitree_api::msg::Request>(
            "/api/sport/request", 10);

        // 2. 创建 Twist 订阅者
        twist_sub_ = this->create_subscription<geometry_msgs::msg::Twist>(
            "cmd_vel", 10,
            std::bind(&TwistBridge::twist_cb, this, _1));
    }

private:
    rclcpp::Publisher<unitree_api::msg::Request>::SharedPtr request_pub_;
    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr twist_sub_;

    void twist_cb(const geometry_msgs::msg::Twist::SharedPtr twist)
    {
        // 3. 转换消息
        unitree_api::msg::Request request;

        // 提取速度值
        double x = twist->linear.x;    // 前后速度
        double y = twist->linear.y;    // 左右速度
        double z = twist->angular.z;   // 旋转速度

        // 默认为平衡站立
        int32_t api_id = ROBOT_SPORT_API_ID_BALANCESTAND;

        // 如果有速度指令，切换到移动模式
        if (x != 0.0 || y != 0.0 || z != 0.0)
        {
            api_id = ROBOT_SPORT_API_ID_MOVE;

            // 生成 JSON 参数
            nlohmann::json js;
            js["x"] = x;
            js["y"] = y;
            js["z"] = z;
            request.parameter = js.dump();

            RCLCPP_INFO(this->get_logger(),
                "速度指令: %s", request.parameter.c_str());
        }

        // 设置 API ID 并发布
        request.header.identity.api_id = api_id;
        request_pub_->publish(request);
    }
};

int main(int argc, char ** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<TwistBridge>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

### 3.3 配置 CMakeLists.txt

添加依赖查找：
```cmake
find_package(geometry_msgs REQUIRED)
find_package(nlohmann_json REQUIRED)

ament_target_dependencies(
  twist_bridge
  "rclcpp"
  "geometry_msgs"
  "unitree_api"
)

target_link_libraries(twist_bridge nlohmann_json::nlohmann_json)
```

如果系统没有安装：
```bash
sudo apt install nlohmann-json3-dev
```

---

## 四、Python 实现

### 4.1 创建 sport_model.py

在 `go2_twist_bridge_py/go2_twist_bridge_py/` 创建 `sport_model.py`：

```python
# Go2 运动控制 API ID 定义
ROBOT_SPORT_API_IDS = {
    "BALANCESTAND": 1002,  # 平衡站立
    "STOPMOVE": 1003,      # 停止运动
    "MOVE": 1008,          # 移动
}
```

### 4.2 编写 twist_bridge.py

打开 `go2_twist_bridge_py/go2_twist_bridge_py/twist_bridge.py`：

```python
'''
功能：Twist 消息桥接
将 geometry_msgs/Twist 转换为 unitree_api/Request

实现步骤：
1. 创建 Request 发布者
2. 创建 Twist 订阅者
3. 在回调函数中转换消息并发布
'''

import rclpy
from rclpy.node import Node
from unitree_api.msg import Request
from geometry_msgs.msg import Twist
from .sport_model import ROBOT_SPORT_API_IDS
import json

class TwistBridge(Node):
    def __init__(self):
        super().__init__('twist_bridge')

        self.get_logger().info(
            "Twist 桥接节点启动：将 geometry_msgs/Twist 转换为 unitree_api/Request"
        )

        # 1. 创建 Request 发布者
        self.request_pub = self.create_publisher(
            Request, "/api/sport/request", 10)

        # 2. 创建 Twist 订阅者
        self.twist_sub = self.create_subscription(
            Twist, "cmd_vel", self.twist_cb, 10)

    def twist_cb(self, twist):
        # 3. 转换消息
        request = Request()

        # 提取速度值
        x = twist.linear.x    # 前后速度
        y = twist.linear.y    # 左右速度
        z = twist.angular.z   # 旋转速度

        # 默认为平衡站立
        api_id = ROBOT_SPORT_API_IDS["BALANCESTAND"]

        # 如果有速度指令，切换到移动模式
        if x != 0 or y != 0 or z != 0:
            api_id = ROBOT_SPORT_API_IDS["MOVE"]

            # 生成 JSON 参数
            js = {"x": x, "y": y, "z": z}
            request.parameter = json.dumps(js)

            self.get_logger().info(f"速度指令: {request.parameter}")

        # 设置 API ID 并发布
        request.header.identity.api_id = api_id
        self.request_pub.publish(request)

def main():
    rclpy.init()
    rclpy.spin(TwistBridge())
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

---

## 五、编译和测试

### 5.1 编译 C++ 版本

```bash
cd ~/unitree_go2_ws
colcon build --packages-select go2_twist_bridge
source install/setup.bash
```

### 5.2 编译 Python 版本

```bash
colcon build --packages-select go2_twist_bridge_py
source install/setup.bash
```

### 5.3 测试运行

**终端1**（启动桥接节点 - C++ 版）：
```bash
source ~/unitree_ros2/setup.sh
cd ~/unitree_go2_ws
source install/setup.bash
ros2 run go2_twist_bridge twist_bridge
```

**或者 Python 版**：
```bash
ros2 run go2_twist_bridge_py twist_bridge
```

**终端2**（使用标准键盘控制）：
```bash
# 安装标准 ROS2 键盘控制工具
sudo apt install ros-humble-teleop-twist-keyboard

# 运行
ros2 run teleop_twist_keyboard teleop_twist_keyboard
```

**预期效果**：
- 按 `i` → Go2 前进
- 按 `,` → Go2 后退
- 按 `j` → Go2 左转
- 按 `l` → Go2 右转

---

## 六、验证消息转换

### 6.1 查看 Twist 消息

```bash
# 查看发布的 Twist 消息
ros2 topic echo /cmd_vel
```

### 6.2 查看 Request 消息

```bash
# 查看转换后的 Request 消息
ros2 topic echo /api/sport/request
```

### 6.3 手动测试桥接

**终端1**（启动桥接）：
```bash
ros2 run go2_twist_bridge twist_bridge
```

**终端2**（手动发布 Twist）：
```bash
ros2 topic pub /cmd_vel geometry_msgs/Twist \
    "{linear: {x: 0.2, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}" \
    --rate 10
```

---

## 七、小结

本节我们学习了：
✅ 理解 ROS2 标准接口的重要性
✅ 实现 Twist 到 Request 的消息转换
✅ 掌握订阅-转换-发布的设计模式
✅ 学会使用 teleop_twist_keyboard 控制 Go2

**关键要点**：
- 消息桥接实现跨平台兼容
- JSON 序列化用于参数传递
- 订阅回调函数中处理转换逻辑

**下一步**：我们将学习机器人可视化和完整驱动包的开发。

---

## 拓展阅读

- [geometry_msgs/Twist](https://docs.ros.org/en/humble/p/geometry_msgs/)
- [teleop_twist_keyboard](https://github.com/ros2/teleop_twist_keyboard)
- [nlohmann/json 文档](https://json.nlohmann.me/)
