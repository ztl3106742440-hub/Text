# 3.3 机器人可视化与完整驱动包

## 学习目标
- 掌握 URDF 模型在 RVIZ2 中的可视化
- 学会发布里程计和 TF 坐标变换
- 理解关节状态发布机制
- 开发完整的 Go2 ROS2 驱动包

---

## 一、机器人模型可视化

### 1.1 什么是 URDF？

**URDF（Unified Robot Description Format）** 是 ROS 中描述机器人模型的标准格式：
- 定义机器人的**连杆（Link）**和**关节（Joint）**
- 包含三维模型文件（.dae, .stl 等）
- 用于仿真和可视化

### 1.2 创建 description 功能包

```bash
cd ~/unitree_go2_ws/src/base
ros2 pkg create go2_description --build-type ament_cmake
```

### 1.3 获取 Go2 URDF 模型

从 Unitree 官网下载：
- 链接：https://support.unitree.com/home/zh/developer/Obtain%20SDK
- 下载 `go2_urdf.zip` 文件

解压后，将以下文件夹复制到 `go2_description/`：
- `dae/` - 3D 模型文件
- `meshes/` - 网格文件
- `urdf/` - URDF 描述文件

同时创建 `launch/` 文件夹。

### 1.4 配置 package.xml

添加依赖：
```xml
<exec_depend>rviz2</exec_depend>
<exec_depend>ros2launch</exec_depend>
<exec_depend>xacro</exec_depend>
<exec_depend>joint_state_publisher</exec_depend>
<exec_depend>robot_state_publisher</exec_depend>
```

### 1.5 配置 CMakeLists.txt

在 `if(BUILD_TESTING)` 之前添加：
```cmake
install(
  DIRECTORY launch dae urdf meshes
  DESTINATION share/${PROJECT_NAME}
)
```

### 1.6 编写 display.launch.py

在 `launch/display.launch.py` 创建：

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration, Command
from launch_ros.parameter_descriptions import ParameterValue
from ament_index_python.packages import get_package_share_directory
from launch.conditions import IfCondition
import os

def generate_launch_description():
    # 获取功能包路径
    pkg_dir = get_package_share_directory("go2_description")

    # 参数：是否使用 joint_state_publisher
    use_jsp = DeclareLaunchArgument(
        name="use_joint_state_publisher",
        default_value="true",
        description="是否启动 joint_state_publisher"
    )

    # 参数：URDF 文件路径
    urdf_arg = DeclareLaunchArgument(
        name="urdf_path",
        default_value=os.path.join(pkg_dir, "urdf", "go2_description.urdf"),
        description="URDF 文件路径"
    )

    # 读取 URDF 文件
    robot_desc = ParameterValue(
        Command(["xacro ", LaunchConfiguration("urdf_path")])
    )

    # robot_state_publisher：发布机器人状态到 TF
    robot_state_pub = Node(
        package="robot_state_publisher",
        executable="robot_state_publisher",
        parameters=[{"robot_description": robot_desc}]
    )

    # joint_state_publisher：发布关节状态（手动调节）
    joint_state_pub = Node(
        package="joint_state_publisher",
        executable="joint_state_publisher",
        condition=IfCondition(LaunchConfiguration("use_joint_state_publisher"))
    )

    return LaunchDescription([
        urdf_arg,
        use_jsp,
        robot_state_pub,
        joint_state_pub
    ])
```

### 1.7 测试模型显示

**编译**：
```bash
cd ~/unitree_go2_ws
colcon build --packages-select go2_description
source install/setup.bash
```

**启动**：
```bash
# 终端1：启动 display
ros2 launch go2_description display.launch.py

# 终端2：启动 RVIZ2
source install/setup.bash
rviz2
```

**在 RVIZ2 中配置**：
1. Fixed Frame → 选择 `base`
2. Add → RobotModel
3. Description Topic → `/robot_description`

你应该能看到 Go2 的 3D 模型。

### 1.8 显示激光雷达点云

Go2 的 URDF 使用 `radar` 作为雷达坐标系，而实际点云使用 `utlidar_lidar`。需要发布静态坐标变换：

```bash
# 临时发布（用于测试）
ros2 run tf2_ros static_transform_publisher \
    --frame-id radar --child-frame-id utlidar_lidar
```

在 RVIZ2 中：
- Add → PointCloud2
- Topic → `/utlidar/cloud`

---

## 二、完整驱动包开发

### 2.1 功能需求

开发一个完整的 Go2 驱动包，集成以下功能：
1. ✅ 机器人模型可视化
2. ✅ 里程计消息发布（`nav_msgs/Odometry`）
3. ✅ TF 坐标变换（odom → base_link）
4. ✅ 关节状态发布（`sensor_msgs/JointState`）
5. ✅ Twist 消息桥接

### 2.2 创建驱动包

```bash
cd ~/unitree_go2_ws/src/base

# C++ 版本
ros2 pkg create go2_driver \
    --build-type ament_cmake \
    --dependencies rclcpp unitree_go nav_msgs tf2 tf2_ros geometry_msgs sensor_msgs \
    --node-name driver

# Python 版本
ros2 pkg create go2_driver_py \
    --build-type ament_python \
    --dependencies rclpy unitree_go nav_msgs geometry_msgs sensor_msgs \
    --node-name driver
```

创建必要的文件夹：
```bash
cd go2_driver
mkdir launch params rviz
```

### 2.3 C++ 驱动节点实现

**package.xml** 确保有以下依赖：
```xml
<depend>nav_msgs</depend>
<depend>tf2</depend>
<depend>tf2_ros</depend>
<depend>sensor_msgs</depend>
<exec_depend>ros2launch</exec_depend>
```

**CMakeLists.txt** 添加：
```cmake
find_package(nav_msgs REQUIRED)
find_package(tf2 REQUIRED)
find_package(tf2_ros REQUIRED)
find_package(sensor_msgs REQUIRED)

ament_target_dependencies(
  driver
  "rclcpp"
  "unitree_go"
  "nav_msgs"
  "tf2"
  "tf2_ros"
  "geometry_msgs"
  "sensor_msgs"
)

install(DIRECTORY launch params rviz
  DESTINATION share/${PROJECT_NAME})
```

**src/driver.cpp**：

```cpp
/*
Go2 驱动节点

功能：
1. 发布里程计消息 (nav_msgs/Odometry)
2. 广播 TF 坐标变换 (odom → base_link)
3. 发布关节状态 (sensor_msgs/JointState)
*/

#include "rclcpp/rclcpp.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "unitree_go/msg/sport_mode_state.hpp"
#include "unitree_go/msg/low_state.hpp"
#include "geometry_msgs/msg/transform_stamped.hpp"
#include "tf2_ros/transform_broadcaster.h"
#include "sensor_msgs/msg/joint_state.hpp"

using namespace std::placeholders;

class Driver : public rclcpp::Node
{
public:
    Driver() : Node("driver")
    {
        // 声明参数
        this->declare_parameter("odom_frame", "odom");
        this->declare_parameter("base_frame", "base");
        this->declare_parameter("publish_tf", true);

        // 获取参数
        odom_frame_ = this->get_parameter("odom_frame").as_string();
        base_frame_ = this->get_parameter("base_frame").as_string();
        publish_tf_ = this->get_parameter("publish_tf").as_bool();

        RCLCPP_INFO(this->get_logger(),
            "Go2 驱动节点启动 - odom: '%s', base: '%s'",
            odom_frame_.c_str(), base_frame_.c_str());

        // 创建 TF 广播器
        tf_broadcaster_ = std::make_unique<tf2_ros::TransformBroadcaster>(*this);

        // 里程计发布者
        odom_pub_ = this->create_publisher<nav_msgs::msg::Odometry>("odom", 10);

        // 订阅高层状态（用于里程计）
        sport_sub_ = this->create_subscription<unitree_go::msg::SportModeState>(
            "/lf/sportmodestate", 10,
            std::bind(&Driver::sport_callback, this, _1));

        // 关节状态发布者
        joint_pub_ = this->create_publisher<sensor_msgs::msg::JointState>("joint_states", 10);

        // 订阅低层状态（用于关节）
        low_sub_ = this->create_subscription<unitree_go::msg::LowState>(
            "/lf/lowstate", 10,
            std::bind(&Driver::low_callback, this, _1));
    }

private:
    std::string odom_frame_, base_frame_;
    bool publish_tf_;

    std::unique_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
    rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr odom_pub_;
    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr joint_pub_;
    rclcpp::Subscription<unitree_go::msg::SportModeState>::SharedPtr sport_sub_;
    rclcpp::Subscription<unitree_go::msg::LowState>::SharedPtr low_sub_;

    // 处理高层状态 → 发布里程计和 TF
    void sport_callback(const unitree_go::msg::SportModeState::SharedPtr msg)
    {
        // 构造里程计消息
        nav_msgs::msg::Odometry odom;
        odom.header.stamp.sec = msg->stamp.sec;
        odom.header.stamp.nanosec = msg->stamp.nanosec;
        odom.header.frame_id = odom_frame_;
        odom.child_frame_id = base_frame_;

        // 位置
        odom.pose.pose.position.x = msg->position[0];
        odom.pose.pose.position.y = msg->position[1];
        odom.pose.pose.position.z = msg->position[2];

        // 姿态（四元数）
        odom.pose.pose.orientation.w = msg->imu_state.quaternion[0];
        odom.pose.pose.orientation.x = msg->imu_state.quaternion[1];
        odom.pose.pose.orientation.y = msg->imu_state.quaternion[2];
        odom.pose.pose.orientation.z = msg->imu_state.quaternion[3];

        // 速度
        odom.twist.twist.linear.x = msg->velocity[0];
        odom.twist.twist.linear.y = msg->velocity[1];
        odom.twist.twist.linear.z = msg->velocity[2];
        odom.twist.twist.angular.z = msg->yaw_speed;

        // 发布里程计
        odom_pub_->publish(odom);

        // 发布 TF 变换
        if (publish_tf_)
        {
            geometry_msgs::msg::TransformStamped tf;
            tf.header.stamp = this->now();
            tf.header.frame_id = odom_frame_;
            tf.child_frame_id = base_frame_;

            tf.transform.translation.x = odom.pose.pose.position.x;
            tf.transform.translation.y = odom.pose.pose.position.y;
            tf.transform.translation.z = odom.pose.pose.position.z;
            tf.transform.rotation = odom.pose.pose.orientation;

            tf_broadcaster_->sendTransform(tf);
        }
    }

    // 处理低层状态 → 发布关节状态
    void low_callback(const unitree_go::msg::LowState::SharedPtr msg)
    {
        sensor_msgs::msg::JointState joint_state;
        joint_state.header.stamp = this->now();

        // Go2 的 12 个关节名称
        joint_state.name = {
            "FL_hip_joint", "FL_thigh_joint", "FL_calf_joint",
            "FR_hip_joint", "FR_thigh_joint", "FR_calf_joint",
            "RL_hip_joint", "RL_thigh_joint", "RL_calf_joint",
            "RR_hip_joint", "RR_thigh_joint", "RR_calf_joint",
        };

        // 提取关节角度
        for (size_t i = 0; i < 12; i++)
        {
            joint_state.position.push_back(msg->motor_state[i].q);
        }

        joint_pub_->publish(joint_state);
    }
};

int main(int argc, char ** argv)
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<Driver>());
    rclcpp::shutdown();
    return 0;
}
```

### 2.4 Launch 文件集成

在 `launch/driver.launch.py` 创建：

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.substitutions import LaunchConfiguration
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.conditions import IfCondition
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # 获取功能包路径
    desc_pkg = get_package_share_directory("go2_description")
    driver_pkg = get_package_share_directory("go2_driver")

    # 参数：是否启动 RVIZ2
    use_rviz = DeclareLaunchArgument(
        name="use_rviz",
        default_value="true"
    )

    return LaunchDescription([
        use_rviz,

        # 1. 包含机器人模型显示
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource(
                os.path.join(desc_pkg, "launch", "display.launch.py")
            ),
            launch_arguments={'use_joint_state_publisher': 'false'}.items()
        ),

        # 2. 启动 RVIZ2（可选）
        Node(
            package="rviz2",
            executable="rviz2",
            arguments=["-d", os.path.join(driver_pkg, "rviz", "display.rviz")],
            condition=IfCondition(LaunchConfiguration("use_rviz"))
        ),

        # 3. 雷达坐标系映射
        Node(
            package="tf2_ros",
            executable="static_transform_publisher",
            arguments=["--frame-id", "radar", "--child-frame-id", "utlidar_lidar"]
        ),

        # 4. Twist 消息桥接
        Node(
            package="go2_twist_bridge",
            executable="twist_bridge"
        ),

        # 5. 驱动节点（里程计、TF、关节状态）
        Node(
            package="go2_driver",
            executable="driver"
        )
    ])
```

### 2.5 参数文件

在 `params/driver.yaml` 创建：

```yaml
/**:
  ros__parameters:
    odom_frame: odom
    base_frame: base
    publish_tf: true
    use_sim_time: false
```

---

## 三、编译和运行

### 3.1 编译所有包

```bash
cd ~/unitree_go2_ws

# 编译
colcon build --packages-select \
    go2_description \
    go2_twist_bridge \
    go2_driver

# 加载环境
source install/setup.bash
```

### 3.2 运行完整驱动

**启动驱动（带 RVIZ）**：
```bash
source ~/unitree_ros2/setup.sh
cd ~/unitree_go2_ws
source install/setup.bash
ros2 launch go2_driver driver.launch.py
```

**启动驱动（不带 RVIZ）**：
```bash
ros2 launch go2_driver driver.launch.py use_rviz:=false
```

### 3.3 测试控制

在另一个终端：
```bash
source install/setup.bash
ros2 run teleop_twist_keyboard teleop_twist_keyboard
```

按 `i` / `,` / `j` / `l` 控制 Go2 移动。

---

## 四、验证功能

### 4.1 查看 TF 树

```bash
# 查看 TF 坐标关系
ros2 run tf2_tools view_frames

# 生成 frames.pdf，可以用 PDF 阅读器打开
```

### 4.2 查看话题列表

```bash
ros2 topic list
```

应该能看到：
- `/odom` - 里程计
- `/joint_states` - 关节状态
- `/cmd_vel` - 速度指令
- `/api/sport/request` - Go2 控制

### 4.3 RVIZ 配置保存

在 RVIZ 中配置好后，点击 `File → Save Config As`，保存到：
```
~/unitree_go2_ws/src/base/go2_driver/rviz/display.rviz
```

下次启动会自动加载配置。

---

## 五、小结

本节我们完成了：
✅ Go2 URDF 模型在 RVIZ2 中的可视化
✅ 里程计消息发布和 TF 坐标变换
✅ 关节状态的实时发布
✅ 完整驱动包的集成和测试

**完整的数据流**：
```
Go2 硬件
  ↓
/lf/sportmodestate (高层状态)
  ↓
driver 节点
  ├→ /odom (里程计)
  ├→ TF: odom → base
  └→ /joint_states (关节)

/cmd_vel (Twist)
  ↓
twist_bridge
  ↓
/api/sport/request
  ↓
Go2 执行
```

**第三章总结**：
- 键盘控制：直接控制 Go2
- Twist 桥接：标准接口兼容
- 完整驱动：集成所有功能

**下一步**：第四章将学习基于 ROS2 通信机制的高级应用。

---

## 拓展阅读

- [URDF 官方教程](http://wiki.ros.org/urdf/Tutorials)
- [TF2 坐标变换](https://docs.ros.org/en/humble/Tutorials/Intermediate/Tf2/Tf2-Main.html)
- [RVIZ2 用户指南](https://github.com/ros2/rviz)
