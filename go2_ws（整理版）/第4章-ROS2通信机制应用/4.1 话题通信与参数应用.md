# 4.1 话题通信与参数应用 - 巡航与位置获取

## 学习目标
- 掌握 ROS2 话题通信的完整流程
- 学会使用参数动态调整节点行为
- 实现 Go2 的速度控制和位置监测
- 理解发布-订阅模式的实际应用

---

## 一、功能简介

### 1.1 案例目标

本节通过两个实例学习话题通信：
1. **巡航控制**：发布速度指令，控制 Go2 移动
2. **位置获取**：订阅里程计，监测 Go2 位置

### 1.2 技术要点

- **话题通信**：Publisher（发布者）和 Subscriber（订阅者）
- **参数服务**：动态配置节点参数
- **定时器**：周期性发布消息

---

## 二、案例1：动态参数控制巡航

### 2.1 需求分析

开发一个节点，通过**动态参数**控制 Go2 的运动：
- 参数 `x`, `y`, `z` 控制线速度和角速度
- 参数 `sport_api_id` 控制运动模式
- 使用 `ros2 param` 命令实时调整

### 2.2 创建功能包

```bash
cd ~/unitree_go2_ws/src/tutorial

# C++ 版本
ros2 pkg create go2_tutorial \
    --build-type ament_cmake \
    --dependencies rclcpp unitree_go unitree_api \
    --node-name go2_ctrl

# Python 版本
ros2 pkg create go2_tutorial_py \
    --build-type ament_python \
    --dependencies rclpy unitree_go unitree_api \
    --node-name go2_ctrl
```

创建必要文件夹：
```bash
cd go2_tutorial
mkdir launch params
```

### 2.3 C++ 实现

**package.xml 添加**：
```xml
<depend>ros2launch</depend>
```

**CMakeLists.txt 添加**：
```cmake
install(DIRECTORY launch params
  DESTINATION share/${PROJECT_NAME})
```

**src/go2_ctrl.cpp**：

```cpp
/*
功能：通过动态参数控制 Go2 运动

实现：
1. 声明参数：sport_api_id, x, y, z
2. 创建定时器，周期性发布控制指令
3. 读取参数值，生成 Request 消息
*/

#include "rclcpp/rclcpp.hpp"
#include "unitree_api/msg/request.hpp"
#include "sport_model.hpp"
#include "nlohmann/json.hpp"

using namespace std::chrono_literals;

class Go2Ctrl : public rclcpp::Node
{
public:
    Go2Ctrl() : Node("go2_ctrl")
    {
        RCLCPP_INFO(this->get_logger(), "Go2 控制节点启动");

        // 声明参数
        this->declare_parameter("sport_api_id", ROBOT_SPORT_API_ID_BALANCESTAND);
        this->declare_parameter("x", 0.0);
        this->declare_parameter("y", 0.0);
        this->declare_parameter("z", 0.0);

        // 创建发布者
        pub_ = this->create_publisher<unitree_api::msg::Request>(
            "/api/sport/request", 10);

        // 创建定时器（100ms = 10Hz）
        timer_ = this->create_wall_timer(
            100ms, std::bind(&Go2Ctrl::timer_callback, this));
    }

private:
    rclcpp::Publisher<unitree_api::msg::Request>::SharedPtr pub_;
    rclcpp::TimerBase::SharedPtr timer_;

    void timer_callback()
    {
        unitree_api::msg::Request request;

        // 读取参数
        auto api_id = this->get_parameter("sport_api_id").as_int();
        request.header.identity.api_id = api_id;

        // 如果是移动模式，设置速度参数
        if (api_id == ROBOT_SPORT_API_ID_MOVE)
        {
            nlohmann::json js;
            js["x"] = this->get_parameter("x").as_double();
            js["y"] = this->get_parameter("y").as_double();
            js["z"] = this->get_parameter("z").as_double();
            request.parameter = js.dump();
        }

        pub_->publish(request);
    }
};

int main(int argc, char ** argv)
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<Go2Ctrl>());
    rclcpp::shutdown();
    return 0;
}
```

**launch/go2_ctrl.launch.py**：

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package="go2_tutorial",
            executable="go2_ctrl"
        )
    ])
```

### 2.4 Python 实现

**go2_tutorial_py/go2_ctrl.py**：

```python
"""
功能：通过动态参数控制 Go2 运动
"""

import rclpy
from rclpy.node import Node
from unitree_api.msg import Request
from sport_model import ROBOT_SPORT_API_IDS
import json

class Go2Ctrl(Node):
    def __init__(self):
        super().__init__('go2_ctrl')

        # 声明参数
        self.declare_parameter("sport_api_id", ROBOT_SPORT_API_IDS["BALANCESTAND"])
        self.declare_parameter("x", 0.0)
        self.declare_parameter("y", 0.0)
        self.declare_parameter("z", 0.0)

        # 创建发布者
        self.pub = self.create_publisher(Request, "/api/sport/request", 10)

        # 创建定时器（0.1s = 10Hz）
        self.timer = self.create_timer(0.1, self.timer_callback)

    def timer_callback(self):
        request = Request()

        # 读取参数
        api_id = self.get_parameter("sport_api_id").value
        request.header.identity.api_id = api_id

        # 如果是移动模式，设置速度参数
        if api_id == ROBOT_SPORT_API_IDS["MOVE"]:
            js = {
                "x": self.get_parameter("x").value,
                "y": self.get_parameter("y").value,
                "z": self.get_parameter("z").value,
            }
            request.parameter = json.dumps(js)

        self.pub.publish(request)

def main():
    rclpy.init()
    rclpy.spin(Go2Ctrl())
    rclpy.shutdown()
```

### 2.5 运行和测试

**编译**：
```bash
cd ~/unitree_go2_ws
colcon build --packages-select go2_tutorial
source install/setup.bash
```

**运行**：
```bash
source ~/unitree_ros2/setup.sh
ros2 launch go2_tutorial go2_ctrl.launch.py
```

**动态调参**：

在另一个终端：
```bash
# 查看当前参数
ros2 param list

# 设置为移动模式
ros2 param set /go2_ctrl sport_api_id 1008

# 设置速度（前进 + 旋转）
ros2 param set /go2_ctrl x 0.2
ros2 param set /go2_ctrl z 0.3

# 停止运动
ros2 param set /go2_ctrl sport_api_id 1003
```

---

## 三、案例2：位置监测与记录

### 3.1 需求分析

订阅里程计消息，当 Go2 移动超过设定距离时，记录并输出位置：
- 订阅 `/odom` 话题
- 计算与上次记录点的距离
- 超过阈值时输出坐标并更新

### 3.2 创建节点

**package.xml 添加**：
```xml
<depend>nav_msgs</depend>
```

**CMakeLists.txt 添加**：
```cmake
find_package(nav_msgs REQUIRED)

add_executable(go2_state src/go2_state.cpp)
ament_target_dependencies(go2_state
  "rclcpp"
  "unitree_go"
  "unitree_api"
  "nav_msgs"
)

install(TARGETS go2_state
  DESTINATION lib/${PROJECT_NAME})
```

**src/go2_state.cpp**：

```cpp
/*
功能：监测 Go2 位置，超过阈值时输出坐标

实现：
1. 订阅里程计消息
2. 计算与上次记录点的距离
3. 超过阈值则输出并更新记录点
*/

#include "rclcpp/rclcpp.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include <cmath>

using namespace std::placeholders;

class Go2State : public rclcpp::Node
{
public:
    Go2State() : Node("go2_state"), is_first_(true)
    {
        RCLCPP_INFO(this->get_logger(), "位置监测节点启动");

        // 声明参数：触发距离阈值
        this->declare_parameter("distance", 0.5);

        // 订阅里程计
        odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>(
            "odom", 10, std::bind(&Go2State::odom_callback, this, _1));
    }

private:
    rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
    double last_x_{0.0}, last_y_{0.0};
    bool is_first_;

    void odom_callback(const nav_msgs::msg::Odometry::SharedPtr msg)
    {
        // 获取当前坐标
        double x = msg->pose.pose.position.x;
        double y = msg->pose.pose.position.y;

        // 第一次接收消息，初始化记录点
        if (is_first_)
        {
            last_x_ = x;
            last_y_ = y;
            is_first_ = false;
            RCLCPP_INFO(this->get_logger(), "起点: (%.2f, %.2f)", x, y);
            return;
        }

        // 计算距离
        double dx = x - last_x_;
        double dy = y - last_y_;
        double distance = std::sqrt(dx*dx + dy*dy);

        // 判断是否超过阈值
        double threshold = this->get_parameter("distance").as_double();
        if (distance > threshold)
        {
            RCLCPP_INFO(this->get_logger(), "新位置: (%.2f, %.2f)", x, y);
            last_x_ = x;
            last_y_ = y;
        }
    }
};

int main(int argc, char ** argv)
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<Go2State>());
    rclcpp::shutdown();
    return 0;
}
```

### 3.3 Launch 文件集成

**launch/go2_state.launch.py**：

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # 包含驱动（提供 odom 话题）
    driver_pkg = get_package_share_directory("go2_driver")
    driver_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(driver_pkg, "launch", "driver.launch.py")
        )
    )

    # 启动位置监测节点
    go2_tutorial_pkg = get_package_share_directory("go2_tutorial")
    state_node = Node(
        package="go2_tutorial",
        executable="go2_state",
        parameters=[
            os.path.join(go2_tutorial_pkg, "params", "go2_state.yaml")
        ]
    )

    return LaunchDescription([
        driver_launch,
        state_node
    ])
```

**params/go2_state.yaml**：

```yaml
/**:
  ros__parameters:
    distance: 0.3
    use_sim_time: false
```

### 3.4 运行测试

```bash
# 编译
colcon build --packages-select go2_tutorial

# 运行
source install/setup.bash
ros2 launch go2_tutorial go2_state.launch.py
```

在另一个终端控制 Go2 移动，观察位置输出。

---

## 四、小结

本节学习了：
✅ 话题通信的发布者和订阅者实现
✅ 参数服务的声明和动态调整
✅ 定时器的使用和消息周期发布
✅ 里程计消息的订阅和解析

**关键概念**：
- **发布者**：周期性发送消息
- **订阅者**：接收并处理消息
- **参数**：动态配置节点行为
- **回调函数**：消息到达时的处理逻辑

**下一步**：学习服务通信，实现远程控制 Go2 的启停。

---

## 拓展阅读

- [ROS2 话题通信详解](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Cpp-Publisher-And-Subscriber.html)
- [ROS2 参数服务](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters.html)
