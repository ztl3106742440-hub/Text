# 4.2 服务通信应用 - 巡航启停控制

## 学习目标
- 理解服务通信的请求-响应模式
- 掌握自定义服务接口的方法
- 实现远程控制 Go2 巡航启停
- 学会参数的远程访问

---

## 一、服务通信简介

### 1.1 什么是服务通信？

**服务（Service）** 是 ROS2 的一种同步通信方式：
- **客户端（Client）**：发送请求，等待响应
- **服务端（Server）**：接收请求，处理并返回结果

```
客户端                  服务端
────────              ────────
发送请求  ────────→    接收请求
          ↑         ↓
等待响应  ←────────    处理并响应
```

### 1.2 与话题通信的区别

| 特性 | 话题（Topic） | 服务（Service） |
|------|-------------|----------------|
| 通信模式 | 发布-订阅 | 请求-响应 |
| 是否阻塞 | 非阻塞 | 阻塞（等待响应） |
| 数据流向 | 单向 | 双向 |
| 适用场景 | 持续数据流 | 偶发性操作 |

### 1.3 案例需求

开发一个服务通信程序：
- **客户端**：发送启停标志（1=启动，0=停止）
- **服务端**：
  - 接收标志，控制 Go2 巡航
  - 返回 Go2 当前位置

---

## 二、自定义服务接口

### 2.1 创建接口包

```bash
cd ~/unitree_go2_ws/src/tutorial
ros2 pkg create go2_tutorial_inter --build-type ament_cmake
```

### 2.2 定义服务接口

在 `go2_tutorial_inter/srv/` 创建 `Cruising.srv`：

```
# 请求：启停标志（1=启动，0=停止）
int32 flag
---
# 响应：机器人位置
geometry_msgs/Point point
```

**说明**：
- `---` 上方是**请求**数据
- `---` 下方是**响应**数据

### 2.3 配置接口包

**package.xml**：
```xml
<buildtool_depend>ament_cmake</buildtool_depend>
<depend>geometry_msgs</depend>
<build_depend>rosidl_default_generators</build_depend>
<exec_depend>rosidl_default_runtime</exec_depend>
<member_of_group>rosidl_interface_packages</member_of_group>
```

**CMakeLists.txt**：
```cmake
find_package(ament_cmake REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "srv/Cruising.srv"
  DEPENDENCIES "geometry_msgs"
)

ament_package()
```

### 2.4 编译接口

```bash
cd ~/unitree_go2_ws
colcon build --packages-select go2_tutorial_inter
source install/setup.bash

# 验证接口
ros2 interface show go2_tutorial_inter/srv/Cruising
```

---

## 三、服务端实现

### 3.1 功能设计

服务端需要：
1. 创建服务，接收启停请求
2. 订阅里程计，获取当前位置
3. 通过远程参数控制 `go2_ctrl` 节点
4. 响应当前位置

### 3.2 C++ 服务端

**package.xml 添加**：
```xml
<depend>geometry_msgs</depend>
<depend>go2_tutorial_inter</depend>
```

**CMakeLists.txt 添加**：
```cmake
find_package(geometry_msgs REQUIRED)
find_package(go2_tutorial_inter REQUIRED)

add_executable(go2_cruising_service src/go2_cruising_service.cpp)
ament_target_dependencies(go2_cruising_service
  "rclcpp"
  "unitree_go"
  "unitree_api"
  "nav_msgs"
  "geometry_msgs"
  "go2_tutorial_inter"
)

install(TARGETS go2_cruising_service
  DESTINATION lib/${PROJECT_NAME})
```

**src/go2_cruising_service.cpp**：

```cpp
/*
功能：巡航服务端
- 接收启停请求（0/1）
- 控制 Go2 巡航
- 响应当前位置
*/

#include "rclcpp/rclcpp.hpp"
#include "go2_tutorial_inter/srv/cruising.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "geometry_msgs/msg/point.hpp"
#include "sport_model.hpp"

using namespace std::chrono_literals;
using namespace std::placeholders;

class CruisingService : public rclcpp::Node
{
public:
    CruisingService() : Node("go2_cruising_service")
    {
        RCLCPP_INFO(this->get_logger(), "巡航服务端启动");

        // 声明巡航速度参数
        this->declare_parameter("x", 0.1);
        this->declare_parameter("y", 0.0);
        this->declare_parameter("z", 0.5);

        // 创建远程参数客户端（连接到 go2_ctrl）
        param_client_ = std::make_shared<rclcpp::AsyncParametersClient>(
            this, "go2_ctrl");

        // 等待参数服务
        while (!param_client_->wait_for_service(1s))
        {
            if (!rclcpp::ok()) return;
            RCLCPP_INFO(this->get_logger(), "等待 go2_ctrl 参数服务...");
        }
        RCLCPP_INFO(this->get_logger(), "成功连接到 go2_ctrl");

        // 订阅里程计（获取位置）
        odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>(
            "odom", 10, std::bind(&CruisingService::odom_cb, this, _1));

        // 创建服务
        service_ = this->create_service<go2_tutorial_inter::srv::Cruising>(
            "cruising", std::bind(&CruisingService::handle_request, this, _1, _2));
    }

private:
    rclcpp::AsyncParametersClient::SharedPtr param_client_;
    rclcpp::Service<go2_tutorial_inter::srv::Cruising>::SharedPtr service_;
    rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
    geometry_msgs::msg::Point current_point_;

    // 里程计回调：更新当前位置
    void odom_cb(const nav_msgs::msg::Odometry::SharedPtr msg)
    {
        current_point_ = msg->pose.pose.position;
    }

    // 服务回调：处理启停请求
    void handle_request(
        const std::shared_ptr<go2_tutorial_inter::srv::Cruising::Request> request,
        std::shared_ptr<go2_tutorial_inter::srv::Cruising::Response> response)
    {
        int32_t api_id;

        if (request->flag != 0)
        {
            // 启动巡航
            api_id = ROBOT_SPORT_API_ID_MOVE;
            RCLCPP_INFO(this->get_logger(), "启动巡航");
        }
        else
        {
            // 停止巡航
            api_id = ROBOT_SPORT_API_ID_STOPMOVE;
            RCLCPP_INFO(this->get_logger(), "停止巡航");
        }

        // 向 go2_ctrl 注入参数
        param_client_->set_parameters({
            this->get_parameter("x"),
            this->get_parameter("y"),
            this->get_parameter("z"),
            rclcpp::Parameter("sport_api_id", api_id),
        });

        // 响应当前位置
        response->point = current_point_;
    }
};

int main(int argc, char ** argv)
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<CruisingService>());
    rclcpp::shutdown();
    return 0;
}
```

### 3.3 Python 服务端

**go2_tutorial_py/go2_cruising_service.py**：

```python
"""
功能：巡航服务端（Python 版本）
"""

import rclpy
from rclpy.node import Node
from go2_tutorial_inter.srv import Cruising
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Point
from unitree_api.msg import Request
from .sport_model import ROBOT_SPORT_API_IDS
import json

class CruisingService(Node):
    def __init__(self):
        super().__init__('go2_cruising_service')

        # 创建服务
        self.service = self.create_service(
            Cruising, "cruising", self.handle_request)

        # 订阅里程计
        self.point = Point()
        self.odom_sub = self.create_subscription(
            Odometry, "odom", self.odom_cb, 10)

        # 声明速度参数
        self.declare_parameter("x", 0.1)
        self.declare_parameter("y", 0.0)
        self.declare_parameter("z", 0.5)

        # 创建发布者（直接控制）
        self.api_id = ROBOT_SPORT_API_IDS["BALANCESTAND"]
        self.req_pub = self.create_publisher(
            Request, "/api/sport/request", 10)
        self.timer = self.create_timer(0.1, self.on_timer)

    def odom_cb(self, msg):
        self.point = msg.pose.pose.position

    def handle_request(self, request, response):
        if request.flag == 0:
            self.get_logger().info("停止巡航")
            self.api_id = ROBOT_SPORT_API_IDS["STOPMOVE"]
        else:
            self.get_logger().info("启动巡航")
            self.api_id = ROBOT_SPORT_API_IDS["MOVE"]

        response.point = self.point
        return response

    def on_timer(self):
        req = Request()
        req.header.identity.api_id = self.api_id

        if self.api_id == ROBOT_SPORT_API_IDS["MOVE"]:
            js = {
                "x": self.get_parameter("x").value,
                "y": self.get_parameter("y").value,
                "z": self.get_parameter("z").value,
            }
            req.parameter = json.dumps(js)

        self.req_pub.publish(req)

def main():
    rclpy.init()
    rclpy.spin(CruisingService())
    rclpy.shutdown()
```

---

## 四、客户端实现

### 4.1 C++ 客户端

**src/go2_cruising_client.cpp**：

```cpp
/*
功能：巡航客户端
发送启停请求，接收位置响应
*/

#include "rclcpp/rclcpp.hpp"
#include "go2_tutorial_inter/srv/cruising.hpp"

using namespace std::chrono_literals;

class CruisingClient : public rclcpp::Node
{
public:
    CruisingClient() : Node("go2_cruising_client")
    {
        client_ = this->create_client<go2_tutorial_inter::srv::Cruising>("cruising");
    }

    bool connect_server()
    {
        while (!client_->wait_for_service(1s))
        {
            if (!rclcpp::ok()) return false;
            RCLCPP_INFO(this->get_logger(), "等待服务...");
        }
        return true;
    }

    void send_request(int32_t flag)
    {
        auto request = std::make_shared<go2_tutorial_inter::srv::Cruising::Request>();
        request->flag = flag;

        auto future = client_->async_send_request(request);

        // 等待响应
        if (rclcpp::spin_until_future_complete(this->get_node_base_interface(), future)
            == rclcpp::FutureReturnCode::SUCCESS)
        {
            auto response = future.get();
            RCLCPP_INFO(this->get_logger(),
                "机器人位置: (%.2f, %.2f, %.2f)",
                response->point.x, response->point.y, response->point.z);
        }
        else
        {
            RCLCPP_ERROR(this->get_logger(), "服务调用失败");
        }
    }

private:
    rclcpp::Client<go2_tutorial_inter::srv::Cruising>::SharedPtr client_;
};

int main(int argc, char ** argv)
{
    if (argc != 2)
    {
        std::cerr << "用法: ros2 run go2_tutorial go2_cruising_client <0|1>" << std::endl;
        return 1;
    }

    rclcpp::init(argc, argv);
    auto client = std::make_shared<CruisingClient>();

    if (!client->connect_server())
    {
        RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "无法连接服务");
        return 1;
    }

    client->send_request(std::atoi(argv[1]));
    rclcpp::shutdown();
    return 0;
}
```

---

## 五、运行测试

### 5.1 编译

```bash
cd ~/unitree_go2_ws
colcon build --packages-select go2_tutorial go2_tutorial_inter
source install/setup.bash
```

### 5.2 启动服务端

```bash
source ~/unitree_ros2/setup.sh
ros2 run go2_tutorial go2_cruising_service
```

### 5.3 调用客户端

**启动巡航**：
```bash
ros2 run go2_tutorial go2_cruising_client 1
```

**停止巡航**：
```bash
ros2 run go2_tutorial go2_cruising_client 0
```

**使用 ros2 service 命令**：
```bash
ros2 service call /cruising go2_tutorial_inter/srv/Cruising "{flag: 1}"
```

---

## 六、小结

本节学习了：
✅ 服务通信的请求-响应模式
✅ 自定义 srv 接口文件
✅ 服务端和客户端的实现
✅ 参数的远程访问

**关键概念**：
- **同步通信**：客户端阻塞等待响应
- **srv 接口**：定义请求和响应数据结构
- **远程参数**：访问其他节点的参数

**下一步**：学习动作通信，实现带进度反馈的导航功能。

---

## 拓展阅读

- [ROS2 服务通信详解](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Cpp-Service-And-Client.html)
- [自定义接口](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Custom-ROS2-Interfaces.html)
